# Next.jsにおける静的レンダリングと動的レンダリング

**公開日:** 2025年11月18日

**原文:** https://nextjs.org/learn/dashboard-app/static-and-dynamic-rendering

---

## 第8章

### 概要

このチャプターでは、前のデータフェッチングレッスンから生じた2つの制限に対処します：

1. データリクエストが意図しないウォーターフォールを作成する
2. ダッシュボードが静的のままで、データ更新がアプリケーションに表示されない

### 静的レンダリングとは？

静的レンダリングは「データのフェッチングとレンダリングがビルド時（デプロイ時）またはデータ再検証時にサーバー上で行われる」場合に発生します。

**利点：**

- **より高速なWebサイト** - プリレンダリングされたコンテンツはキャッシュされ、Vercelなどのプラットフォームでグローバルに配布でき、世界中でより高速なアクセスが可能になります
- **サーバー負荷の削減** - キャッシュされたコンテンツはリクエストごとの動的生成の必要性を排除し、計算コストを削減します
- **SEO** - プリレンダリングされたコンテンツは検索エンジンがインデックスしやすく、ランキングを向上させます

静的レンダリングはデータなしのUI、またはブログ投稿や商品ページなどのユーザー間で共有されるデータに適しています。頻繁に更新されるパーソナライズされたダッシュボードには適しません。

### 動的レンダリングとは？

動的レンダリングは「リクエスト時（ユーザーがページを訪問するとき）にサーバー上でコンテンツをレンダリング」します。

**利点：**

- **リアルタイムデータ** - アプリケーションは頻繁に更新またはリアルタイムの情報を表示できます
- **ユーザー固有のコンテンツ** - ダッシュボードとプロファイル（パーソナライズされたデータ付き）は提供しやすい
- **リクエスト時間情報** - CookieとURLサーチパラメータへのアクセスが可能になります

### 遅いデータフェッチをシミュレートする

チュートリアルは課題を実演しています。1つのデータリクエストが他より遅い場合、ページロード全体はブロックされます。

**コード例** - `app/lib/data.ts`でシミュレートするため、3秒の遅延のコメントを外します：

```typescript
export async function fetchRevenue() {
  try {
    console.log('Fetching revenue data...');
    await new Promise((resolve) => setTimeout(resolve, 3000));

    const data = await sql<Revenue[]>`SELECT * FROM revenue`;

    console.log('Data fetch completed after 3 seconds.');

    return data;
  } catch (error) {
    console.error('Database Error:', error);
    throw new Error('Failed to fetch revenue data.');
  }
}
```

### キーテイクアウェイ

「動的レンダリングでは、アプリケーションはあなたの最も遅いデータフェッチと同じ速度でしか動作しません。」

---

**次のチャプター:** ストリーミング—ストリーミングとローディングスケルトンを通じてユーザー体験を改善する方法を学びます。
